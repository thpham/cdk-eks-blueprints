"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WindowsBuilder = void 0;
const stacks_1 = require("../stacks");
const addons = require("../addons");
const utils = require("../utils");
const clusterproviders = require("../cluster-providers");
const resourceproviders = require("../resource-providers");
const aws_cdk_lib_1 = require("aws-cdk-lib");
const eks = require("aws-cdk-lib/aws-eks");
const ec2 = require("aws-cdk-lib/aws-ec2");
const iam = require("aws-cdk-lib/aws-iam");
const aws_eks_1 = require("aws-cdk-lib/aws-eks");
const ts_deepmerge_1 = require("ts-deepmerge");
/**
 * Default props to be used when creating the non-windows and windows nodes
 * for Windows EKS cluster
 */
const defaultOptions = {
    kubernetesVersion: eks.KubernetesVersion.of("1.28"),
    instanceClass: ec2.InstanceClass.M5,
    instanceSize: ec2.InstanceSize.XLARGE4,
    nodeRole: resourceproviders.getNamedResource("node-role"),
    windowsAmiType: aws_eks_1.NodegroupAmiType.WINDOWS_FULL_2022_X86_64,
    desiredNodeCount: 2,
    minNodeSize: 2,
    maxNodeSize: 3,
    blockDeviceSize: 50,
    noScheduleForWindowsNodes: true,
    clusterProviderTags: {
        "Name": "blueprints-windows-eks-cluster",
        "Type": "generic-windows-cluster"
    },
    genericNodeGroupOptions: {
        nodegroupName: "default-linux",
        tags: {
            "Name": "Mng-linux",
            "Type": "Managed-linux-Node-Group",
            "LaunchTemplate": "Linux-Launch-Template",
        }
    },
    windowsNodeGroupOptions: {
        nodegroupName: "default-windows",
        amiType: aws_eks_1.NodegroupAmiType.WINDOWS_CORE_2022_X86_64,
        tags: {
            "Name": "Managed-Node-Group",
            "Type": "Windows-Node-Group",
            "LaunchTemplate": "WindowsLT",
            "kubernetes.io/cluster/windows-eks-blueprint": "owned"
        }
    }
};
/**
 * This builder class helps you prepare a blueprint for setting up
 * windows nodes with EKS cluster. The `WindowsBuilder` creates the following:
 * 1. An EKS Cluster` with passed k8s version and cluster tags.
 * 2. A non-windows nodegroup for standard software.
 * 3. A windows nodegroup to schedule windows workloads
 */
class WindowsBuilder extends stacks_1.BlueprintBuilder {
    /**
     * This method helps you prepare a blueprint for setting up windows nodes with
     * usage tracking addon
     */
    static builder(options) {
        const builder = new WindowsBuilder();
        const mergedOptions = (0, ts_deepmerge_1.merge)(defaultOptions, options);
        builder
            .clusterProvider(new clusterproviders.GenericClusterProvider({
            version: mergedOptions.kubernetesVersion,
            tags: mergedOptions.clusterProviderTags,
            role: resourceproviders.getResource(context => {
                return new iam.Role(context.scope, 'ClusterRole', {
                    assumedBy: new iam.ServicePrincipal("eks.amazonaws.com"),
                    managedPolicies: [
                        iam.ManagedPolicy.fromAwsManagedPolicyName("AmazonEKSClusterPolicy"),
                        iam.ManagedPolicy.fromAwsManagedPolicyName("AmazonEKSVPCResourceController")
                    ]
                });
            }),
            managedNodeGroups: [
                buildGenericNodeGroup(mergedOptions),
                buildWindowsNodeGroup(mergedOptions)
            ]
        }))
            .addOns(new addons.NestedStackAddOn({
            id: "usage-tracking-addon",
            builder: UsageTrackingAddOn.builder(),
        }));
        return builder;
    }
    enableKarpenter() {
        return this.addOns(new addons.KarpenterAddOn(this.karpenterProps));
    }
    withKarpenterProps(props) {
        this.karpenterProps = { ...this.karpenterProps, ...utils.cloneDeep(props) };
        return this;
    }
}
exports.WindowsBuilder = WindowsBuilder;
/**
 * Nested stack that is used as tracker for Windows Accelerator
 */
class UsageTrackingAddOn extends aws_cdk_lib_1.NestedStack {
    static builder() {
        return {
            build(scope, id, props) {
                return new UsageTrackingAddOn(scope, id, props);
            }
        };
    }
    constructor(scope, id, props) {
        super(scope, id, utils.withUsageTracking(UsageTrackingAddOn.USAGE_ID, props));
    }
}
UsageTrackingAddOn.USAGE_ID = "qs-1ubotj5kl";
/**
 *  Return the instanceType based off nodegroup or if not defined from options instanceClass and instanceSize. Default to m5.4xlarge
 * @param nodegroupOptions To override instanceType return
 * @param nodegroup default cluster level settings
 * @returns clusterprovider.ManagedNodeGroup
 */
function getInstanceType(nodegroupOptions, windowsOptions) {
    if (nodegroupOptions.instanceTypes) {
        return nodegroupOptions.instanceTypes;
    }
    if (windowsOptions.instanceClass && windowsOptions.instanceSize)
        return [new ec2.InstanceType(`${windowsOptions.instanceClass}.${windowsOptions.instanceSize}`)];
    return [new ec2.InstanceType('m5.4xlarge')];
}
/**
 * This function adds a generic node group to the cluster.
 * @param: options: WindowsOptions
 * @returns: blueprints.ManagedNodeGroup
 */
function buildGenericNodeGroup(options, overrideOptions) {
    let currentOptions = options.genericNodeGroupOptions;
    if (overrideOptions) {
        currentOptions = (0, ts_deepmerge_1.merge)(options.genericNodeGroupOptions, overrideOptions);
    }
    return {
        id: currentOptions.nodegroupName || "",
        amiType: currentOptions.amiType,
        instanceTypes: getInstanceType(currentOptions, options),
        desiredSize: currentOptions.desiredSize,
        minSize: currentOptions.minSize,
        maxSize: currentOptions.maxSize,
        nodeRole: currentOptions.nodeRole,
        nodeGroupSubnets: { subnetType: ec2.SubnetType.PRIVATE_WITH_EGRESS },
        tags: currentOptions.tags,
    };
}
/**
 * This function adds a windows node group to the cluster.
 * @param options: WindowsOptions
 * @returns: blueprints.ManagedNodeGroup
 */
function buildWindowsNodeGroup(options) {
    const result = buildGenericNodeGroup(options, options.windowsNodeGroupOptions);
    if (options.noScheduleForWindowsNodes) {
        utils.setPath(result, "taints", [
            {
                key: "os",
                value: "windows",
                effect: eks.TaintEffect.NO_SCHEDULE
            }
        ]);
    }
    return result;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2luZG93cy1idWlsZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vbGliL2J1aWxkZXJzL3dpbmRvd3MtYnVpbGRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSxzQ0FBNkM7QUFDN0Msb0NBQW9DO0FBQ3BDLGtDQUFrQztBQUVsQyx5REFBeUQ7QUFDekQsMkRBQTJEO0FBQzNELDZDQUE0RDtBQUU1RCwyQ0FBMkM7QUFDM0MsMkNBQTJDO0FBQzNDLDJDQUEyQztBQUMzQyxpREFBdUQ7QUFDdkQsK0NBQXFDO0FBdUVyQzs7O0dBR0c7QUFDSCxNQUFNLGNBQWMsR0FBbUI7SUFDbkMsaUJBQWlCLEVBQUUsR0FBRyxDQUFDLGlCQUFpQixDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUM7SUFDbkQsYUFBYSxFQUFFLEdBQUcsQ0FBQyxhQUFhLENBQUMsRUFBRTtJQUNuQyxZQUFZLEVBQUUsR0FBRyxDQUFDLFlBQVksQ0FBQyxPQUFPO0lBQ3RDLFFBQVEsRUFBRSxpQkFBaUIsQ0FBQyxnQkFBZ0IsQ0FBQyxXQUFXLENBQWE7SUFDckUsY0FBYyxFQUFFLDBCQUFnQixDQUFDLHdCQUF3QjtJQUN6RCxnQkFBZ0IsRUFBRSxDQUFDO0lBQ25CLFdBQVcsRUFBRSxDQUFDO0lBQ2QsV0FBVyxFQUFFLENBQUM7SUFDZCxlQUFlLEVBQUUsRUFBRTtJQUNuQix5QkFBeUIsRUFBRSxJQUFJO0lBQy9CLG1CQUFtQixFQUFFO1FBQ2pCLE1BQU0sRUFBRSxnQ0FBZ0M7UUFDeEMsTUFBTSxFQUFFLHlCQUF5QjtLQUNwQztJQUNELHVCQUF1QixFQUFFO1FBQ3JCLGFBQWEsRUFBRSxlQUFlO1FBQzlCLElBQUksRUFBRTtZQUNGLE1BQU0sRUFBRSxXQUFXO1lBQ25CLE1BQU0sRUFBRSwwQkFBMEI7WUFDbEMsZ0JBQWdCLEVBQUUsdUJBQXVCO1NBQzVDO0tBQ0o7SUFDRCx1QkFBdUIsRUFBRTtRQUNyQixhQUFhLEVBQUUsaUJBQWlCO1FBQ2hDLE9BQU8s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QyxPQUFPLEVBQUUsT0FBTyxDQUFDLHVCQUF1QixDQUFDLENBQUM7SUFFL0UsSUFBRyxPQUFPLENBQUMseUJBQXlCLEVBQUUsQ0FBQztRQUNuQyxLQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxRQUFRLEVBQUU7WUFDNUI7Z0JBQ0ksR0FBRyxFQUFFLElBQUk7Z0JBQ1QsS0FBSyxFQUFFLFNBQVM7Z0JBQ2hCLE1BQU0sRUFBRSxHQUFHLENBQUMsV0FBVyxDQUFDLFdBQVc7YUFDdEM7U0FDSixDQUFDLENBQUM7SUFDUCxDQUFDO0lBRUQsT0FBTyxNQUFNLENBQUM7QUFDbEIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJsdWVwcmludEJ1aWxkZXIgfSBmcm9tICcuLi9zdGFja3MnO1xuaW1wb3J0ICogYXMgYWRkb25zIGZyb20gJy4uL2FkZG9ucyc7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tIFwiLi4vdXRpbHNcIjtcbmltcG9ydCAqIGFzIHNwaSBmcm9tICcuLi9zcGknO1xuaW1wb3J0ICogYXMgY2x1c3RlcnByb3ZpZGVycyBmcm9tICcuLi9jbHVzdGVyLXByb3ZpZGVycyc7XG5pbXBvcnQgKiBhcyByZXNvdXJjZXByb3ZpZGVycyBmcm9tICcuLi9yZXNvdXJjZS1wcm92aWRlcnMnO1xuaW1wb3J0IHsgTmVzdGVkU3RhY2ssIE5lc3RlZFN0YWNrUHJvcHMgfSBmcm9tICdhd3MtY2RrLWxpYic7XG5pbXBvcnQgeyBDb25zdHJ1Y3QgfSBmcm9tICdjb25zdHJ1Y3RzJztcbmltcG9ydCAqIGFzIGVrcyBmcm9tIFwiYXdzLWNkay1saWIvYXdzLWVrc1wiO1xuaW1wb3J0ICogYXMgZWMyIGZyb20gXCJhd3MtY2RrLWxpYi9hd3MtZWMyXCI7XG5pbXBvcnQgKiBhcyBpYW0gZnJvbSAnYXdzLWNkay1saWIvYXdzLWlhbSc7XG5pbXBvcnQgeyBOb2RlZ3JvdXBBbWlUeXBlIH0gZnJvbSAnYXdzLWNkay1saWIvYXdzLWVrcyc7XG5pbXBvcnQgeyBtZXJnZSB9IGZyb20gXCJ0cy1kZWVwbWVyZ2VcIjtcblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIFdpbmRvd3MgQnVpbGRlci5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBXaW5kb3dzT3B0aW9ucyB7XG4gICAgLyoqXG4gICAgICogUmVxdWlyZWQsIEt1YmVybmV0ZXMgdmVyc2lvbiB0byB1c2UgZm9yIHRoZSBjbHVzdGVyLlxuICAgICAqL1xuICAgIGt1YmVybmV0ZXNWZXJzaW9uOiBla3MuS3ViZXJuZXRlc1ZlcnNpb247XG5cbiAgICAvKipcbiAgICAgKiBSZXF1aXJlZCwgSW5zdGFuY2UgY2xhc3MgdG8gdXNlIGZvciB0aGUgY2x1c3Rlci5cbiAgICAgKi9cbiAgICBpbnN0YW5jZUNsYXNzOiBlYzIuSW5zdGFuY2VDbGFzcztcblxuICAgIC8qKlxuICAgICAqIFJlcXVpcmVkLCBJbnN0YW5jZSBzaXplIHRvIHVzZSBmb3IgdGhlIGNsdXN0ZXIuXG4gICAgICovXG4gICAgaW5zdGFuY2VTaXplOiBlYzIuSW5zdGFuY2VTaXplO1xuXG4gICAgLyoqXG4gICAgICogb3B0aW9uYWwsIE5vZGUgSUFNIFJvbGUgdG8gYmUgYXR0YWNoZWQgdG8gV2luZG93c1xuICAgICAqIGFuZCBOb24td2luZG93cyBub2Rlcy5cbiAgICAgKi9cbiAgICBub2RlUm9sZT86IGlhbS5Sb2xlO1xuXG4gICAgLyoqXG4gICAgICogT3B0aW9uYWwsIEFNSSBUeXBlIGZvciBXaW5kb3dzIE5vZGVzXG4gICAgICovXG4gICAgd2luZG93c0FtaVR5cGU/OiBOb2RlZ3JvdXBBbWlUeXBlO1xuXG4gICAgLyoqXG4gICAgICogT3B0aW9uYWwsIERlc2lyZWQgbnVtYmVyIG9mIG5vZGVzIHRvIHVzZSBmb3IgdGhlIGNsdXN0ZXIuXG4gICAgICovXG4gICAgZGVzaXJlZE5vZGVDb3VudD86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIE9wdGlvbmFsLCBNaW5pbXVtIG51bWJlciBvZiBub2RlcyB0byB1c2UgZm9yIHRoZSBjbHVzdGVyLlxuICAgICAqL1xuICAgIG1pbk5vZGVTaXplPzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogT3B0aW9uYWwsIE1heGltdW0gbnVtYmVyIG9mIG5vZGVzIHRvIHVzZSBmb3IgdGhlIGNsdXN0ZXIuXG4gICAgICovXG4gICAgbWF4Tm9kZVNpemU/OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBPcHRpb25hbCwgQmxvY2sgZGV2aWNlIHNpemUuXG4gICAgICovXG4gICAgYmxvY2tEZXZpY2VTaXplPzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogT3B0aW9uYWwsIE5vIFNjaGVkdWxlIGZvciBXaW5kb3dzIE5vZGVzLCB0aGlzIGFsbG93cyBXaW5kb3dzXG4gICAgICogbm9kZXMgdG8gYmUgbWFya2VkIGFzIG5vLXNjaGVkdWxlIGJ5IGRlZmF1bHQgdG8gcHJldmVudCBhbnlcbiAgICAgKiBsaW51eCB3b3JrbG9hZHMgZnJvbSBzY2hlZHVsaW5nLlxuICAgICAqL1xuICAgIG5vU2NoZWR1bGVGb3JXaW5kb3dzTm9kZXM/OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogT3B0aW9uYWwsIENsdXN0ZXIgUHJvdmlkZXIgVGFncy5cbiAgICAgKi9cbiAgICBjbHVzdGVyUHJvdmlkZXJUYWdzPzoge1xuICAgICAgICBba2V5OiBzdHJpbmddOiBzdHJpbmc7XG4gICAgfTtcblxuICAgIGdlbmVyaWNOb2RlR3JvdXBPcHRpb25zOiBla3MuTm9kZWdyb3VwT3B0aW9ucztcblxuICAgIHdpbmRvd3NOb2RlR3JvdXBPcHRpb25zOiBla3MuTm9kZWdyb3VwT3B0aW9uc1xufVxuXG4vKipcbiAqIERlZmF1bHQgcHJvcHMgdG8gYmUgdXNlZCB3aGVuIGNyZWF0aW5nIHRoZSBub24td2luZG93cyBhbmQgd2luZG93cyBub2Rlc1xuICogZm9yIFdpbmRvd3MgRUtTIGNsdXN0ZXJcbiAqL1xuY29uc3QgZGVmYXVsdE9wdGlvbnM6IFdpbmRvd3NPcHRpb25zID0ge1xuICAgIGt1YmVybmV0ZXNWZXJzaW9uOiBla3MuS3ViZXJuZXRlc1ZlcnNpb24ub2YoXCIxLjI4XCIpLFxuICAgIGluc3RhbmNlQ2xhc3M6IGVjMi5JbnN0YW5jZUNsYXNzLk01LFxuICAgIGluc3RhbmNlU2l6ZTogZWMyLkluc3RhbmNlU2l6ZS5YTEFSR0U0LFxuICAgIG5vZGVSb2xlOiByZXNvdXJjZXByb3ZpZGVycy5nZXROYW1lZFJlc291cmNlKFwibm9kZS1yb2xlXCIpIGFzIGlhbS5Sb2xlLFxuICAgIHdpbmRvd3NBbWlUeXBlOiBOb2RlZ3JvdXBBbWlUeXBlLldJTkRPV1NfRlVMTF8yMDIyX1g4Nl82NCxcbiAgICBkZXNpcmVkTm9kZUNvdW50OiAyLFxuICAgIG1pbk5vZGVTaXplOiAyLFxuICAgIG1heE5vZGVTaXplOiAzLFxuICAgIGJsb2NrRGV2aWNlU2l6ZTogNTAsXG4gICAgbm9TY2hlZHVsZUZvcldpbmRvd3NOb2RlczogdHJ1ZSxcbiAgICBjbHVzdGVyUHJvdmlkZXJUYWdzOiB7XG4gICAgICAgIFwiTmFtZVwiOiBcImJsdWVwcmludHMtd2luZG93cy1la3MtY2x1c3RlclwiLFxuICAgICAgICBcIlR5cGVcIjogXCJnZW5lcmljLXdpbmRvd3MtY2x1c3RlclwiXG4gICAgfSxcbiAgICBnZW5lcmljTm9kZUdyb3VwT3B0aW9uczoge1xuICAgICAgICBub2RlZ3JvdXBOYW1lOiBcImRlZmF1bHQtbGludXhcIixcbiAgICAgICAgdGFnczoge1xuICAgICAgICAgICAgXCJOYW1lXCI6IFwiTW5nLWxpbnV4XCIsXG4gICAgICAgICAgICBcIlR5cGVcIjogXCJNYW5hZ2VkLWxpbnV4LU5vZGUtR3JvdXBcIixcbiAgICAgICAgICAgIFwiTGF1bmNoVGVtcGxhdGVcIjogXCJMaW51eC1MYXVuY2gtVGVtcGxhdGVcIixcbiAgICAgICAgfVxuICAgIH0sXG4gICAgd2luZG93c05vZGVHcm91cE9wdGlvbnM6IHtcbiAgICAgICAgbm9kZWdyb3VwTmFtZTogXCJkZWZhdWx0LXdpbmRvd3NcIixcbiAgICAgICAgYW1pVHlwZTogTm9kZWdyb3VwQW1pVHlwZS5XSU5ET1dTX0NPUkVfMjAyMl9YODZfNjQsXG4gICAgICAgIHRhZ3M6IHtcbiAgICAgICAgICAgIFwiTmFtZVwiOiBcIk1hbmFnZWQtTm9kZS1Hcm91cFwiLFxuICAgICAgICAgICAgXCJUeXBlXCI6IFwiV2luZG93cy1Ob2RlLUdyb3VwXCIsXG4gICAgICAgICAgICBcIkxhdW5jaFRlbXBsYXRlXCI6IFwiV2luZG93c0xUXCIsXG4gICAgICAgICAgICBcImt1YmVybmV0ZXMuaW8vY2x1c3Rlci93aW5kb3dzLWVrcy1ibHVlcHJpbnRcIjogXCJvd25lZFwiXG4gICAgICAgIH1cbiAgICB9XG4gIH07XG5cbi8qKlxuICogVGhpcyBidWlsZGVyIGNsYXNzIGhlbHBzIHlvdSBwcmVwYXJlIGEgYmx1ZXByaW50IGZvciBzZXR0aW5nIHVwXG4gKiB3aW5kb3dzIG5vZGVzIHdpdGggRUtTIGNsdXN0ZXIuIFRoZSBgV2luZG93c0J1aWxkZXJgIGNyZWF0ZXMgdGhlIGZvbGxvd2luZzpcbiAqIDEuIEFuIEVLUyBDbHVzdGVyYCB3aXRoIHBhc3NlZCBrOHMgdmVyc2lvbiBhbmQgY2x1c3RlciB0YWdzLlxuICogMi4gQSBub24td2luZG93cyBub2RlZ3JvdXAgZm9yIHN0YW5kYXJkIHNvZnR3YXJlLlxuICogMy4gQSB3aW5kb3dzIG5vZGVncm91cCB0byBzY2hlZHVsZSB3aW5kb3dzIHdvcmtsb2Fkc1xuICovXG5leHBvcnQgY2xhc3MgV2luZG93c0J1aWxkZXIgZXh0ZW5kcyBCbHVlcHJpbnRCdWlsZGVyIHtcblxuICAgIHByaXZhdGUga2FycGVudGVyUHJvcHM6YWRkb25zLkthcnBlbnRlckFkZE9uUHJvcHM7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBoZWxwcyB5b3UgcHJlcGFyZSBhIGJsdWVwcmludCBmb3Igc2V0dGluZyB1cCB3aW5kb3dzIG5vZGVzIHdpdGhcbiAgICAgKiB1c2FnZSB0cmFja2luZyBhZGRvblxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgYnVpbGRlcihvcHRpb25zOiBXaW5kb3dzT3B0aW9ucyk6IFdpbmRvd3NCdWlsZGVyIHtcbiAgICAgICAgY29uc3QgYnVpbGRlciA9IG5ldyBXaW5kb3dzQnVpbGRlcigpO1xuICAgICAgICBjb25zdCBtZXJnZWRPcHRpb25zID0gbWVyZ2UoZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgICAgIGJ1aWxkZXJcbiAgICAgICAgICAgIC5jbHVzdGVyUHJvdmlkZXIoXG4gICAgICAgICAgICAgICAgbmV3IGNsdXN0ZXJwcm92aWRlcnMuR2VuZXJpY0NsdXN0ZXJQcm92aWRlcih7XG4gICAgICAgICAgICAgICAgICAgIHZlcnNpb246IG1lcmdlZE9wdGlvbnMua3ViZXJuZXRlc1ZlcnNpb24sXG4gICAgICAgICAgICAgICAgICAgIHRhZ3M6IG1lcmdlZE9wdGlvbnMuY2x1c3RlclByb3ZpZGVyVGFncyxcbiAgICAgICAgICAgICAgICAgICAgcm9sZTogcmVzb3VyY2Vwcm92aWRlcnMuZ2V0UmVzb3VyY2UoY29udGV4dCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGlhbS5Sb2xlKGNvbnRleHQuc2NvcGUsICdDbHVzdGVyUm9sZScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3N1bWVkQnk6IG5ldyBpYW0uU2VydmljZVByaW5jaXBhbChcImVrcy5hbWF6b25hd3MuY29tXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hbmFnZWRQb2xpY2llczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpYW0uTWFuYWdlZFBvbGljeS5mcm9tQXdzTWFuYWdlZFBvbGljeU5hbWUoXCJBbWF6b25FS1NDbHVzdGVyUG9saWN5XCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpYW0uTWFuYWdlZFBvbGljeS5mcm9tQXdzTWFuYWdlZFBvbGljeU5hbWUoXCJBbWF6b25FS1NWUENSZXNvdXJjZUNvbnRyb2xsZXJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIG1hbmFnZWROb2RlR3JvdXBzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBidWlsZEdlbmVyaWNOb2RlR3JvdXAobWVyZ2VkT3B0aW9ucyksXG4gICAgICAgICAgICAgICAgICAgICAgICBidWlsZFdpbmRvd3NOb2RlR3JvdXAobWVyZ2VkT3B0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAuYWRkT25zKFxuICAgICAgICAgICAgICAgIG5ldyBhZGRvbnMuTmVzdGVkU3RhY2tBZGRPbih7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBcInVzYWdlLXRyYWNraW5nLWFkZG9uXCIsXG4gICAgICAgICAgICAgICAgICAgIGJ1aWxkZXI6IFVzYWdlVHJhY2tpbmdBZGRPbi5idWlsZGVyKCksXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICApO1xuICAgICAgICByZXR1cm4gYnVpbGRlcjtcbiAgICB9XG5cbiAgICBwdWJsaWMgZW5hYmxlS2FycGVudGVyKCk6IFdpbmRvd3NCdWlsZGVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkT25zKFxuICAgICAgICAgICAgbmV3IGFkZG9ucy5LYXJwZW50ZXJBZGRPbih0aGlzLmthcnBlbnRlclByb3BzKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIHB1YmxpYyB3aXRoS2FycGVudGVyUHJvcHMocHJvcHM6YWRkb25zLkthcnBlbnRlckFkZE9uUHJvcHMpIDogdGhpcyB7XG4gICAgICAgIHRoaXMua2FycGVudGVyUHJvcHMgPSB7IC4uLnRoaXMua2FycGVudGVyUHJvcHMsIC4uLnV0aWxzLmNsb25lRGVlcChwcm9wcykgfTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG59XG5cbi8qKlxuICogTmVzdGVkIHN0YWNrIHRoYXQgaXMgdXNlZCBhcyB0cmFja2VyIGZvciBXaW5kb3dzIEFjY2VsZXJhdG9yXG4gKi9cbmNsYXNzIFVzYWdlVHJhY2tpbmdBZGRPbiBleHRlbmRzIE5lc3RlZFN0YWNrIHtcblxuICAgIHN0YXRpYyByZWFkb25seSBVU0FHRV9JRCA9IFwicXMtMXVib3RqNWtsXCI7XG5cbiAgICBwdWJsaWMgc3RhdGljIGJ1aWxkZXIoKTogc3BpLk5lc3RlZFN0YWNrQnVpbGRlciB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBidWlsZChzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogTmVzdGVkU3RhY2tQcm9wcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVXNhZ2VUcmFja2luZ0FkZE9uKHNjb3BlLCBpZCwgcHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBOZXN0ZWRTdGFja1Byb3BzKSB7XG4gICAgICAgIHN1cGVyKHNjb3BlLCBpZCwgdXRpbHMud2l0aFVzYWdlVHJhY2tpbmcoVXNhZ2VUcmFja2luZ0FkZE9uLlVTQUdFX0lELCBwcm9wcykpO1xuICAgIH1cbn1cblxuLyoqXG4gKiAgUmV0dXJuIHRoZSBpbnN0YW5jZVR5cGUgYmFzZWQgb2ZmIG5vZGVncm91cCBvciBpZiBub3QgZGVmaW5lZCBmcm9tIG9wdGlvbnMgaW5zdGFuY2VDbGFzcyBhbmQgaW5zdGFuY2VTaXplLiBEZWZhdWx0IHRvIG01LjR4bGFyZ2VcbiAqIEBwYXJhbSBub2RlZ3JvdXBPcHRpb25zIFRvIG92ZXJyaWRlIGluc3RhbmNlVHlwZSByZXR1cm5cbiAqIEBwYXJhbSBub2RlZ3JvdXAgZGVmYXVsdCBjbHVzdGVyIGxldmVsIHNldHRpbmdzXG4gKiBAcmV0dXJucyBjbHVzdGVycHJvdmlkZXIuTWFuYWdlZE5vZGVHcm91cFxuICovXG5mdW5jdGlvbiBnZXRJbnN0YW5jZVR5cGUobm9kZWdyb3VwT3B0aW9uczogZWtzLk5vZGVncm91cE9wdGlvbnMsIHdpbmRvd3NPcHRpb25zOiBXaW5kb3dzT3B0aW9ucyk6IGVjMi5JbnN0YW5jZVR5cGVbXSB7XG5cbiAgICBpZiAoIG5vZGVncm91cE9wdGlvbnMuaW5zdGFuY2VUeXBlcyApIHsgcmV0dXJuIG5vZGVncm91cE9wdGlvbnMuaW5zdGFuY2VUeXBlczsgfVxuXG4gICAgaWYgKCB3aW5kb3dzT3B0aW9ucy5pbnN0YW5jZUNsYXNzICYmIHdpbmRvd3NPcHRpb25zLmluc3RhbmNlU2l6ZSApXG4gICAgICAgIHJldHVybiBbIG5ldyBlYzIuSW5zdGFuY2VUeXBlKGAke3dpbmRvd3NPcHRpb25zLmluc3RhbmNlQ2xhc3N9LiR7d2luZG93c09wdGlvbnMuaW5zdGFuY2VTaXplfWApIF07XG5cbiAgICByZXR1cm4gWyBuZXcgZWMyLkluc3RhbmNlVHlwZSgnbTUuNHhsYXJnZScpXTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGFkZHMgYSBnZW5lcmljIG5vZGUgZ3JvdXAgdG8gdGhlIGNsdXN0ZXIuXG4gKiBAcGFyYW06IG9wdGlvbnM6IFdpbmRvd3NPcHRpb25zXG4gKiBAcmV0dXJuczogYmx1ZXByaW50cy5NYW5hZ2VkTm9kZUdyb3VwXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkR2VuZXJpY05vZGVHcm91cChvcHRpb25zOiBXaW5kb3dzT3B0aW9ucywgb3ZlcnJpZGVPcHRpb25zPzogZWtzLk5vZGVncm91cE9wdGlvbnMpOiBjbHVzdGVycHJvdmlkZXJzLk1hbmFnZWROb2RlR3JvdXAge1xuXG4gICAgbGV0IGN1cnJlbnRPcHRpb25zID0gb3B0aW9ucy5nZW5lcmljTm9kZUdyb3VwT3B0aW9ucztcbiAgICBpZiAoIG92ZXJyaWRlT3B0aW9ucyApIHsgY3VycmVudE9wdGlvbnMgPSBtZXJnZShvcHRpb25zLmdlbmVyaWNOb2RlR3JvdXBPcHRpb25zLCBvdmVycmlkZU9wdGlvbnMpOyB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBpZDogY3VycmVudE9wdGlvbnMubm9kZWdyb3VwTmFtZSB8fCBcIlwiLFxuICAgICAgICBhbWlUeXBlOiBjdXJyZW50T3B0aW9ucy5hbWlUeXBlLFxuICAgICAgICBpbnN0YW5jZVR5cGVzOiBnZXRJbnN0YW5jZVR5cGUoY3VycmVudE9wdGlvbnMsIG9wdGlvbnMpLFxuICAgICAgICBkZXNpcmVkU2l6ZTogY3VycmVudE9wdGlvbnMuZGVzaXJlZFNpemUsXG4gICAgICAgIG1pblNpemU6IGN1cnJlbnRPcHRpb25zLm1pblNpemUsXG4gICAgICAgIG1heFNpemU6IGN1cnJlbnRPcHRpb25zLm1heFNpemUsXG4gICAgICAgIG5vZGVSb2xlOiBjdXJyZW50T3B0aW9ucy5ub2RlUm9sZSxcbiAgICAgICAgbm9kZUdyb3VwU3VibmV0czogeyBzdWJuZXRUeXBlOiBlYzIuU3VibmV0VHlwZS5QUklWQVRFX1dJVEhfRUdSRVNTIH0sXG4gICAgICAgIHRhZ3M6IGN1cnJlbnRPcHRpb25zLnRhZ3MsXG4gICAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGFkZHMgYSB3aW5kb3dzIG5vZGUgZ3JvdXAgdG8gdGhlIGNsdXN0ZXIuXG4gKiBAcGFyYW0gb3B0aW9uczogV2luZG93c09wdGlvbnNcbiAqIEByZXR1cm5zOiBibHVlcHJpbnRzLk1hbmFnZWROb2RlR3JvdXBcbiAqL1xuZnVuY3Rpb24gYnVpbGRXaW5kb3dzTm9kZUdyb3VwKG9wdGlvbnM6IFdpbmRvd3NPcHRpb25zKTogY2x1c3RlcnByb3ZpZGVycy5NYW5hZ2VkTm9kZUdyb3VwIHtcblxuICAgIGNvbnN0IHJlc3VsdCA9IGJ1aWxkR2VuZXJpY05vZGVHcm91cChvcHRpb25zLCBvcHRpb25zLndpbmRvd3NOb2RlR3JvdXBPcHRpb25zKTtcblxuICAgIGlmKG9wdGlvbnMubm9TY2hlZHVsZUZvcldpbmRvd3NOb2Rlcykge1xuICAgICAgICB1dGlscy5zZXRQYXRoKHJlc3VsdCwgXCJ0YWludHNcIiwgW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGtleTogXCJvc1wiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBcIndpbmRvd3NcIixcbiAgICAgICAgICAgICAgICBlZmZlY3Q6IGVrcy5UYWludEVmZmVjdC5OT19TQ0hFRFVMRVxuICAgICAgICAgICAgfVxuICAgICAgICBdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuIl19