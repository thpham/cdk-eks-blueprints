"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.semverComparator = void 0;
exports.listChartVersions = listChartVersions;
exports.checkHelmChartVersion = checkHelmChartVersion;
const utils_1 = require("../../utils");
/**
 * Semver comparator, simplistic implementation. Might require additional
 * logic for correct semver comparison.
 *
 * @param a
 * @param b
 * @returns
 */
const semverComparator = (a, b) => {
    a = trimVersion(a);
    b = trimVersion(b);
    const a1 = a.split('.');
    const b1 = b.split('.');
    const len = Math.min(a1.length, b1.length);
    for (let i = 0; i < len; i++) {
        const a2 = +a1[i] || 0;
        const b2 = +b1[i] || 0;
        if (a2 !== b2) {
            return a2 > b2 ? -1 : 1;
        }
    }
    return b1.length - a1.length;
};
exports.semverComparator = semverComparator;
/**
 * Remove leading "v". Placeholder to extend (e.g. remove -rc, -beta, etc.);
 * @param v semver format version
 * @returns
 */
function trimVersion(v) {
    return v.charAt(0) == 'v' ? v.substring(1) : v;
}
/**
 * Lists chart versions for a given helm chart.
 * @param chart
 * @returns
 */
function listChartVersions(chart) {
    // TODO make function async and use async HTTP client to get results
    if (chart.repository) {
        if (chart.repository.startsWith("oci:")) {
            return []; // skip for now if OCI repo
        }
        const helmRepository = (0, utils_1.loadExternalYaml)(chart.repository + "/index.yaml");
        const versions = Object.values(helmRepository[0]['entries'][chart.chart])
            .map((e) => { return e['version']; });
        // TODO: refactor to support dictionary of keywords that qualify as non-production
        return versions.filter(e => e.includes(".") && !e.includes("beta") && !e.includes("alpha") && !e.includes("dev") && !e.includes("rc"));
    }
    else {
        return [];
    }
}
/**
 * Checks the provided helm chart version against the repository.
 * Validation is successful if there is no higher version registered in the repository.
 * @param chart
 * @returns
 */
function checkHelmChartVersion(chart) {
    let versions = listChartVersions(chart);
    if (versions === null || versions.length == 0) {
        console.warn("No versions are found for " + chart.chart + " in repository " + chart.repository);
        return {
            allVersions: versions,
            highestVersion: undefined,
            latestVersion: false
        };
    }
    versions = versions.sort(exports.semverComparator);
    const latestVersion = (trimVersion(versions[0]) === trimVersion(chart.version));
    if (latestVersion) {
        utils_1.userLog.info(`Chart ${chart.chart}-${chart.version} is at the latest version.`);
    }
    else {
        utils_1.userLog.warn(`Upgrade is needed for chart ${chart.chart}-${chart.version}: latest version is ${versions[0]}.`);
    }
    return {
        allVersions: versions,
        highestVersion: versions[0],
        latestVersion: latestVersion
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGVsbS12ZXJzaW9uLWNoZWNrZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9saWIvYWRkb25zL2hlbG0tYWRkb24vaGVsbS12ZXJzaW9uLWNoZWNrZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBbUVBLDhDQWNDO0FBUUQsc0RBdUJDO0FBaEhELHVDQUF3RDtBQUt4RDs7Ozs7OztHQU9HO0FBQ0ksTUFBTSxnQkFBZ0IsR0FBRyxDQUFDLENBQVMsRUFBRSxDQUFTLEVBQUUsRUFBRTtJQUNyRCxDQUFDLEdBQUcsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ25CLENBQUMsR0FBRyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFFbkIsTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUN4QixNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBRXhCLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDM0MsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDO1FBQzNCLE1BQU0sRUFBRSxHQUFHLENBQUMsRUFBRSxDQUFFLENBQUMsQ0FBRSxJQUFJLENBQUMsQ0FBQztRQUN6QixNQUFNLEVBQUUsR0FBRyxDQUFDLEVBQUUsQ0FBRSxDQUFDLENBQUUsSUFBSSxDQUFDLENBQUM7UUFFekIsSUFBSSxFQUFFLEtBQUssRUFBRSxFQUFFLENBQUM7WUFDWixPQUFPLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDNUIsQ0FBQztJQUNMLENBQUM7SUFFRCxPQUFPLEVBQUUsQ0FBQyxNQUFNLEdBQUcsRUFBRSxDQUFDLE1BQU0sQ0FBQztBQUNqQyxDQUFDLENBQUM7QUFsQlcsUUFBQSxnQkFBZ0Isb0JBa0IzQjtBQUVGOzs7O0dBSUc7QUFDSCxTQUFTLFdBQVcsQ0FBQyxDQUFTO0lBQzFCLE9BQU8sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNwRCxDQUFDO0FBc0JEOzs7O0dBSUc7QUFDSCxTQUFnQixpQkFBaUIsQ0FBQyxLQUF1QjtJQUNyRCxvRUFBb0U7SUFDcEUsSUFBSSxLQUFLLENBQUMsVUFBVSxFQUFFLENBQUM7UUFDbkIsSUFBSSxLQUFLLENBQUMsVUFBVyxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDO1lBQ3ZDLE9BQU8sRUFBRSxDQUFDLENBQUMsMkJBQTJCO1FBQzFDLENBQUM7UUFDRCxNQUFNLGNBQWMsR0FBRyxJQUFBLHdCQUFnQixFQUFDLEtBQUssQ0FBQyxVQUFVLEdBQUcsYUFBYSxDQUFDLENBQUM7UUFDMUUsTUFBTSxRQUFRLEdBQWEsTUFBTSxDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO2FBQzlFLEdBQUcsQ0FBQyxDQUFDLENBQU0sRUFBRSxFQUFFLEdBQUcsT0FBTyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUMvQyxrRkFBa0Y7UUFDbEYsT0FBTyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztJQUMzSSxDQUFDO1NBQU0sQ0FBQztRQUNKLE9BQU8sRUFBRSxDQUFDO0lBQ2QsQ0FBQztBQUNMLENBQUM7QUFFRDs7Ozs7R0FLRztBQUNILFNBQWdCLHFCQUFxQixDQUFDLEtBQXVCO0lBQ3pELElBQUksUUFBUSxHQUFHLGlCQUFpQixDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3hDLElBQUcsUUFBUSxLQUFLLElBQUksSUFBSSxRQUFRLENBQUMsTUFBTSxJQUFJLENBQUMsRUFBRSxDQUFDO1FBQzNDLE9BQU8sQ0FBQyxJQUFJLENBQUMsNEJBQTRCLEdBQUcsS0FBSyxDQUFDLEtBQUssR0FBRyxpQkFBaUIsR0FBRyxLQUFLLENBQUMsVUFBVSxDQUFFLENBQUM7UUFDakcsT0FBTztZQUNILFdBQVcsRUFBRSxRQUFRO1lBQ3JCLGNBQWMsRUFBRSxTQUFTO1lBQ3pCLGFBQWEsRUFBRSxLQUFLO1NBQ3ZCLENBQUM7SUFDTixDQUFDO0lBQ0QsUUFBUSxHQUFHLFFBQVEsQ0FBQyxJQUFJLENBQUMsd0JBQWdCLENBQUMsQ0FBQztJQUMzQyxNQUFNLGFBQWEsR0FBRyxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxXQUFXLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7SUFDaEYsSUFBRyxhQUFhLEVBQUUsQ0FBQztRQUNmLGVBQU8sQ0FBQyxJQUFJLENBQUMsU0FBUyxLQUFLLENBQUMsS0FBSyxJQUFJLEtBQUssQ0FBQyxPQUFPLDRCQUE0QixDQUFFLENBQUM7SUFDckYsQ0FBQztTQUNJLENBQUM7UUFDRixlQUFPLENBQUMsSUFBSSxDQUFDLCtCQUErQixLQUFLLENBQUMsS0FBSyxJQUFJLEtBQUssQ0FBQyxPQUFPLHVCQUF1QixRQUFRLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ25ILENBQUM7SUFDRCxPQUFPO1FBQ0gsV0FBVyxFQUFFLFFBQVE7UUFDckIsY0FBYyxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUM7UUFDM0IsYUFBYSxFQUFFLGFBQWE7S0FDL0IsQ0FBQztBQUNOLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBsb2FkRXh0ZXJuYWxZYW1sLCB1c2VyTG9nIH0gZnJvbSBcIi4uLy4uL3V0aWxzXCI7XG5pbXBvcnQgeyBIZWxtQ2hhcnRDb25maWd1cmF0aW9uIH0gZnJvbSBcIi4va3ViZWN0bC1wcm92aWRlclwiO1xuXG5leHBvcnQgdHlwZSBIZWxtQ2hhcnRWZXJzaW9uID0gT21pdDxIZWxtQ2hhcnRDb25maWd1cmF0aW9uLCBcIm5hbWVcIiB8IFwibmFtZXNwYWNlXCIgfCAgXCJyZWxlYXNlXCIgfCBcInZhbHVlc1wiPjtcblxuLyoqXG4gKiBTZW12ZXIgY29tcGFyYXRvciwgc2ltcGxpc3RpYyBpbXBsZW1lbnRhdGlvbi4gTWlnaHQgcmVxdWlyZSBhZGRpdGlvbmFsIFxuICogbG9naWMgZm9yIGNvcnJlY3Qgc2VtdmVyIGNvbXBhcmlzb24uXG4gKiBcbiAqIEBwYXJhbSBhIFxuICogQHBhcmFtIGIgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGNvbnN0IHNlbXZlckNvbXBhcmF0b3IgPSAoYTogc3RyaW5nLCBiOiBzdHJpbmcpID0+IHsgXG4gICAgYSA9IHRyaW1WZXJzaW9uKGEpO1xuICAgIGIgPSB0cmltVmVyc2lvbihiKTtcblxuICAgIGNvbnN0IGExID0gYS5zcGxpdCgnLicpO1xuICAgIGNvbnN0IGIxID0gYi5zcGxpdCgnLicpO1xuXG4gICAgY29uc3QgbGVuID0gTWF0aC5taW4oYTEubGVuZ3RoLCBiMS5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgYTIgPSArYTFbIGkgXSB8fCAwO1xuICAgICAgICBjb25zdCBiMiA9ICtiMVsgaSBdIHx8IDA7XG4gICAgICAgIFxuICAgICAgICBpZiAoYTIgIT09IGIyKSB7XG4gICAgICAgICAgICByZXR1cm4gYTIgPiBiMiA/IC0xIDogMTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBiMS5sZW5ndGggLSBhMS5sZW5ndGg7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBsZWFkaW5nIFwidlwiLiBQbGFjZWhvbGRlciB0byBleHRlbmQgKGUuZy4gcmVtb3ZlIC1yYywgLWJldGEsIGV0Yy4pO1xuICogQHBhcmFtIHYgc2VtdmVyIGZvcm1hdCB2ZXJzaW9uXG4gKiBAcmV0dXJucyBcbiAqL1xuZnVuY3Rpb24gdHJpbVZlcnNpb24odjogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHYuY2hhckF0KDApID09ICAndicgPyB2LnN1YnN0cmluZygxKSA6IHY7XG59XG4vKipcbiAqIFJlcHJlc2VudCByZXN1bHQgb2YgaGVsbSBjaGFydCB2ZXJzaW9uIHZhbGlkYXRpb24gYWdhaW5zdCBuZXdlciB2ZXJzaW9uc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIENoZWNrVmVyc2lvblJlc3VsdCB7XG5cbiAgICAvKipcbiAgICAgKiBDb250YWlucyB0aGUgaGlnaGVzdCB2ZXJzaW9uIG9mIHRoZSBoZWxtIGNoYXJ0IGRpc2NvdmVyZWQgaW4gdGhlIGhlbG0gY2hhcnQgcmVwb3NpdG9yeS5cbiAgICAgKi9cbiAgICBoaWdoZXN0VmVyc2lvbjogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgIFxuICAgIC8qKlxuICAgICAqIFRydWUgaWYgdGhlIHByb3ZpZGVkIHZlcnNpb24gaXMgdGhlIGxhdGVzdCB2ZXJzaW9uIGluIHRoZSBoZWxtIGNoYXJ0IHJlcG9zaXRvcnkuIE90aGVyd2lzZSwgZmFsc2UuXG4gICAgICovXG4gICAgbGF0ZXN0VmVyc2lvbjogYm9vbGVhbixcblxuICAgIC8qKlxuICAgICAqIEFsbCBkaXNjb3ZlcmVkIHZlcnNpb25zIG9mIHRoZSBjaGFydCwgZGlzY292ZXJlZCBpbiB0aGUgcHJvdmlkZWQgaGVsbSBjaGFydCByZXBvc2l0b3J5LlxuICAgICAqL1xuICAgIGFsbFZlcnNpb25zOiBzdHJpbmdbXTtcbn1cblxuLyoqXG4gKiBMaXN0cyBjaGFydCB2ZXJzaW9ucyBmb3IgYSBnaXZlbiBoZWxtIGNoYXJ0LlxuICogQHBhcmFtIGNoYXJ0IFxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaXN0Q2hhcnRWZXJzaW9ucyhjaGFydDogSGVsbUNoYXJ0VmVyc2lvbik6IHN0cmluZ1tdIHtcbiAgICAvLyBUT0RPIG1ha2UgZnVuY3Rpb24gYXN5bmMgYW5kIHVzZSBhc3luYyBIVFRQIGNsaWVudCB0byBnZXQgcmVzdWx0c1xuICAgIGlmIChjaGFydC5yZXBvc2l0b3J5KSB7XG4gICAgICAgIGlmIChjaGFydC5yZXBvc2l0b3J5IS5zdGFydHNXaXRoKFwib2NpOlwiKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdOyAvLyBza2lwIGZvciBub3cgaWYgT0NJIHJlcG9cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZWxtUmVwb3NpdG9yeSA9IGxvYWRFeHRlcm5hbFlhbWwoY2hhcnQucmVwb3NpdG9yeSArIFwiL2luZGV4LnlhbWxcIik7XG4gICAgICAgIGNvbnN0IHZlcnNpb25zOiBzdHJpbmdbXSA9IE9iamVjdC52YWx1ZXMoaGVsbVJlcG9zaXRvcnlbMF1bJ2VudHJpZXMnXVtjaGFydC5jaGFydF0pXG4gICAgICAgICAgICAubWFwKChlOiBhbnkpID0+IHsgcmV0dXJuIGVbJ3ZlcnNpb24nXTsgfSk7XG4gICAgICAgIC8vIFRPRE86IHJlZmFjdG9yIHRvIHN1cHBvcnQgZGljdGlvbmFyeSBvZiBrZXl3b3JkcyB0aGF0IHF1YWxpZnkgYXMgbm9uLXByb2R1Y3Rpb25cbiAgICAgICAgcmV0dXJuIHZlcnNpb25zLmZpbHRlcihlID0+IGUuaW5jbHVkZXMoXCIuXCIpICYmICFlLmluY2x1ZGVzKFwiYmV0YVwiKSAmJiAhZS5pbmNsdWRlcyhcImFscGhhXCIpICYmICFlLmluY2x1ZGVzKFwiZGV2XCIpICYmICFlLmluY2x1ZGVzKFwicmNcIikpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG59XG5cbi8qKlxuICogQ2hlY2tzIHRoZSBwcm92aWRlZCBoZWxtIGNoYXJ0IHZlcnNpb24gYWdhaW5zdCB0aGUgcmVwb3NpdG9yeS5cbiAqIFZhbGlkYXRpb24gaXMgc3VjY2Vzc2Z1bCBpZiB0aGVyZSBpcyBubyBoaWdoZXIgdmVyc2lvbiByZWdpc3RlcmVkIGluIHRoZSByZXBvc2l0b3J5LiBcbiAqIEBwYXJhbSBjaGFydCBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tIZWxtQ2hhcnRWZXJzaW9uKGNoYXJ0OiBIZWxtQ2hhcnRWZXJzaW9uKSA6IENoZWNrVmVyc2lvblJlc3VsdCB7XG4gICAgbGV0IHZlcnNpb25zID0gbGlzdENoYXJ0VmVyc2lvbnMoY2hhcnQpO1xuICAgIGlmKHZlcnNpb25zID09PSBudWxsIHx8IHZlcnNpb25zLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIk5vIHZlcnNpb25zIGFyZSBmb3VuZCBmb3IgXCIgKyBjaGFydC5jaGFydCArIFwiIGluIHJlcG9zaXRvcnkgXCIgKyBjaGFydC5yZXBvc2l0b3J5ICk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhbGxWZXJzaW9uczogdmVyc2lvbnMsXG4gICAgICAgICAgICBoaWdoZXN0VmVyc2lvbjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbGF0ZXN0VmVyc2lvbjogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmVyc2lvbnMgPSB2ZXJzaW9ucy5zb3J0KHNlbXZlckNvbXBhcmF0b3IpO1xuICAgIGNvbnN0IGxhdGVzdFZlcnNpb24gPSAodHJpbVZlcnNpb24odmVyc2lvbnNbMF0pID09PSB0cmltVmVyc2lvbihjaGFydC52ZXJzaW9uKSk7XG4gICAgaWYobGF0ZXN0VmVyc2lvbikge1xuICAgICAgICB1c2VyTG9nLmluZm8oYENoYXJ0ICR7Y2hhcnQuY2hhcnR9LSR7Y2hhcnQudmVyc2lvbn0gaXMgYXQgdGhlIGxhdGVzdCB2ZXJzaW9uLmAgKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHVzZXJMb2cud2FybihgVXBncmFkZSBpcyBuZWVkZWQgZm9yIGNoYXJ0ICR7Y2hhcnQuY2hhcnR9LSR7Y2hhcnQudmVyc2lvbn06IGxhdGVzdCB2ZXJzaW9uIGlzICR7dmVyc2lvbnNbMF19LmApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBhbGxWZXJzaW9uczogdmVyc2lvbnMsXG4gICAgICAgIGhpZ2hlc3RWZXJzaW9uOiB2ZXJzaW9uc1swXSxcbiAgICAgICAgbGF0ZXN0VmVyc2lvbjogbGF0ZXN0VmVyc2lvblxuICAgIH07XG59Il19